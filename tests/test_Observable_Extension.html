<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Observer &amp; Observable Extension</title>
    <style type="text/css">
      @import "../../dijit/themes/claro/claro.css";
      @import "../../dijit/themes/claro/document.css";
      @import "../../dijit/tests/css/dijitTests.css";
    </style>

    <script type="text/javascript">
      var dojoConfig = {
            async: true,
            parseOnLoad: true,
            isDebug: true,
            baseUrl: "../../",
            packages: [
              { name: "dojo", location: "dojo" },
              { name: "doh",  location: "util/doh" },
              { name: "store",location: "indexedStore" }
            ]
      };
    </script>

    <script type="text/javascript" src="../../dojo/dojo.js"></script>
    <script type="text/javascript">
      require([
        "doh/runner",
        "dojo/_base/declare",
				"dojo/promise/Promise",
        "dojo/ready",
        "dojo/when",
        "store/_base/_Store",
        "store/_base/_Indexed",
        "store/_base/_Loader",
        "store/_base/Observer",
				"store/listener/Listener",
				"store/extension/Hierarchy",
				"store/extension/Observable",
				"store/extension/Watch"
        ], function( doh, declare, Promise, ready, when,
											_Store, _Indexed, _Loader, Observer, Listener, Hierarchy,
											Observable, Watch ) {
					"use strict";
					
					// IMPORTANT:
					//		Don't change the number of records without updating any of
					//		the range and count tests.
					// - there are 8 unique parents.
					var data = [
						{ "name":"Root", "parent":[], "hair":"none" },
						{ "name":"Abe", "age":65, "parent":["Root"], "hair":"none" },
						{ "name":"Mona", "age":65, "parent":["Root"], "hair":"none" },
						{ "name":"Jacqueline", "age":63, "parent":["Root"], "hair":"none" },
						{ "name":"Homer", "age":42, "parent":["Abe","Mona"], "hair":"none" },
						{ "name":"Marge", "age":35, "parent":["Jacqueline"], "hair":"blue" },
						{ "name":"Ned", "age":40, "parent":["Root"], "hair":"none" },
						{ "name":"Lisa", "age":10, "parent":["Homer","Marge"], "hair":"blond" },
						{ "name":"Bart", "age":9, "parent":["Homer","Marge"], "hair":"blond" },
						{ "name":"Maggie", "age":2, "parent":["Homer","Marge"], "hair":"blond" },
						{ "name":"Patty", "age":37, "parent":["Jacqueline"], "hair":"blue" },
						{ "name":"Selma", "age":38, "parent":["Jacqueline"], "hair":"blue" },
						{ "name":"Rod", "age":9, "parent":["Ned"], "hair":"blond" },
						{ "name":"Todd", "age":8, "parent":["Ned"], "hair":"blond" },
						{ "name":"Apu", "age":40, "parent":["Root"], "hair":"black" },
						{ "name":"Manjula", "age":40, "parent":["Apu"], "hair":"brown"}
					];
					var undef;

					var count = {};

					function action (from, to) {
						var type = from < 0 ? (to < 0 ? "none" : "add") : (to < 0 ? "delete" : "change");
						return type;
					}

					function listener0(obj, from, to) {
						var type = action(from,to);
						count[type] = count[type] ? count[type] + 1 : 1;
					};
					function listener1(obj, from, to) {
						var type = action(from,to);
						count[type] = count[type] ? count[type] + 1 : 1;
					};
					function listener2(obj, from, to) {
						var type = action(from,to);
						count[type] = count[type] ? count[type] + 1 : 1;
					};
					function listener99(obj, from, to) {
						var type = action(from,to);
						count[type] = count[type] ? count[type] + 1 : 1;
					};
					
					doh.register("Observer & Observable Extension", [
						{
							name: "Create Observer, add and remove listener",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ();

								var query   = {hair:"blond"};
								var results = store.query(query); 
								var destroyed = false;
								
								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );
								observer.done( function () {
									destroyed = true;
								});

								t.is (results, observer.results)

								// Create listener manually
								var lstn0  = new Listener( listener0 );
								var handle = observer.addListener( lstn0 );
								// Create listener automatically.
								observer.addListener( listener1 );
								observer.removeListener( listener1 );

								// remove first listener using the handle.
								handle.remove();

								// The observer should be 'destroyed'
								t.is (null, observer.results)
								t.e( Error, observer, "addListener", [listener0]);
								t.t(destroyed);

							}
						},

						{
							name: "Create Observer, add and remove multiple listeners",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ();

								var query   = {hair:"blond"};
								var results = store.query(query); 
								var destroyed = false;
								
								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );
								observer.done( function () {
									destroyed = true;
								});

								t.is (results, observer.results)

								// Create listener automatically.
								observer.addListener( listener0 );
								observer.addListener( listener1 );
								observer.addListener( listener2 );

								var listeners = observer.getListeners();
								t.is (3, listeners.length);
								
								// Remove all listeners
								observer.removeListener();

								// The observer should be 'destroyed'
								t.is (null, observer.results)
								t.e( Error, observer, "addListener", [listener0]);
								t.t(destroyed);

							}
						},

						{
							name: "Create Observer, add multiple, destroy Observer",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ();

								var query   = {hair:"blond"};
								var results = store.query(query); 
								var destroyed = false;
								
								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );
								observer.done( function () {
									destroyed = true;
								});

								t.is (results, observer.results)

								// Create listener automatically.
								observer.addListener( listener0 );
								observer.addListener( listener1 );
								observer.addListener( listener2 );

								var listeners = observer.getListeners();
								t.is (3, listeners.length);

								// Destroy Observer
								observer.destroy();
								observer.destroy();		// this should be Ok.

								listeners = observer.getListeners();
								// The observer should be 'destroyed'
								t.is (null, observer.results)
								t.e( Error, observer, "addListener", [listener0]);
								t.t(destroyed);
							}
						},

						{
							name: "Observe Query, no listener, empty store, auto load",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ({autoLoad:true, keyPath:"name"});
								var defer = new doh.Deferred();

								var query   = {hair:"blond"};
								var results = store.query(query); 

								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );

								store.ready( 
									defer.getTestCallback(
										function (store) {
											// There is NO Observer listener so fetch the results 
											// directly from the observer.
											var obsRes = observer.results;
											t.is( obsRes, results );
											t.is( 0, obsRes.total );

											// Marge does not match query
											store.put( {name:"Marge", hair:"blue"});
											t.is( 0, obsRes.length );
											t.is( 0, obsRes.total );

											// Bart matches the query
											store.put( {name:"Bart", hair:"blond"});
											t.is( 1, obsRes.length );
											t.is( 1, obsRes.total );

											store.put( {name:"Bart", hair:"brown"});
											t.is( 0, obsRes.length );
											t.is( 0, obsRes.total );

											observer.destroy();
											// Observer destroyed, adding a listener should fail
											t.e( Error, observer, "addListener", [listener0]);
										}
									),
									function (err) {
										defer.errback(err);
									}
								);
								return defer;
							}
						},

						{
							name: "Observe Range, no listener, empty store, auto load",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ({autoLoad:true, keyPath:"name"});
								var defer = new doh.Deferred();

								var results = store.getRange(); 

								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, null, null, store.revision );

								store.ready( 
									defer.getTestCallback(
										function (store) {
											// There is NO Observer listener so fetch the results 
											// directly from the observer.
											var obsRes = observer.results;
											t.is( obsRes, results );
											t.is( 0, obsRes.total );

											// Marge does match range
											store.put( {name:"Marge", hair:"blue"});
											t.is( 1, obsRes.length );
											t.is( 1, obsRes.total );

											store.put( {name:"Bart", hair:"blond"});
											t.is( 2, obsRes.length );
											t.is( 2, obsRes.total );

											// Updating Bart has no effect on the range
											var bart = store.get("Bart");
											bart.hair = "brown";
											store.put( bart );
											t.is( 2, obsRes.length );
											t.is( 2, obsRes.total );

											store.remove("Bart");
											t.is( 1, obsRes.length );
											t.is( 1, obsRes.total );
											
											observer.destroy();
											// Observer destroyed, adding a listener should fail
											t.e( Error, observer, "addListener", [listener0]);
										}
									),
									function (err) {
										defer.errback(err);
									}
								);
								return defer;
							}
						},

						{
							name: "Observe Query, no listener, empty store and deferred load",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ({autoLoad: false, keyPath:"name"});
								var defer = new doh.Deferred();

								// Because store load is deferred results should be a Promise.
								var query   = {hair:"blond"};
								var results = store.query(query); 

								t.t( results instanceof Promise );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );

								// Deferred load (to get the store ready and resolve results)
								store.load();
								
								store.ready( 
									defer.getTestCallback(
										function (store) {
											// There is NO Observer listener so fetch the results 
											// directly from the observer.
											when( observer.results, function (dataset) {
												t.is (0, dataset.length);
												t.is (0, dataset.total);
												t.is (0, results.total);
											});
											store.put( {name:"Bart", hair:"blond"});
											when( observer.results, function (dataset) {
												t.is (1, dataset.length);
												t.is (1, dataset.total);
												t.is (1, results.total);
											});
											observer.destroy();
										}
									),
									function (err) {
										defer.errback(err);
									}
								);
								return defer;
							}
						},

						{
							name: "Observe Query, with listener, empty store, auto load",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ({autoLoad:true, keyPath:"name"});
								var defer = new doh.Deferred();

								count = {};		// reset counters
								
								var query   = {hair:"blond"};
								var results = store.query(query); 

								t.t( results instanceof Array );

								// Because the Observable extension is not loaded we must create
								// the observer instance manually.
								var observer = new Observer( store, results, query, null, store.revision );
								observer.addListener( listener0, true );

								store.ready( 
									defer.getTestCallback(
										function (store) {
											var obsRes = observer.results;
											t.is( obsRes, results );
											t.is( 0, obsRes.total );

											store.put( {name:"Marge", hair:"blue"});	// No match
											store.put( {name:"Lisa", hair:"blond"});	// Match -> add
											store.put( {name:"Bart", hair:"blond"});	// Match -> add
											store.put( {name:"Bart", hair:"blond"});	// Match -> update
											store.put( {name:"Bart", hair:"brown"});	// No match -> delete

											// Only Lisa should be left
											t.is( "Lisa", obsRes[0].name );
											t.is( 1, obsRes.length );
											t.is( 1, obsRes.total );

											t.is( 2, count.add );
											t.is( 1, count.change );
											t.is( 1, count.delete );

											observer.destroy();
										}
									),
									function (err) {
										defer.errback(err);
									}
								);
								return defer;
							}
						},


						{
							name: "Observe Query, with listener",
							timeout: 2000,
							runTest: function (t) {
								var Store = declare( [_Store, _Indexed]);
								var store = new Store ({data:data, keyPath:"name"});
								var defer = new doh.Deferred();

								count = {add:0, delete:0, change:0};		// reset counters
								
								store.ready( 
									defer.getTestCallback(
										function (store) {

											// Query using a property function
											var query = {age: function (val, key, obj) {
												return (val >= 40 && val <= 50);
											}};
											var results = store.query( query );
											var observer = new Observer( store, results, query, null, store.revision );
											observer.addListener( listener0, true );		// Include updates
											observer.addListener( listener1, false );		// exclude updates
											
											t.is( 4, results.length );
											t.is( 4, results.total );
											t.is( 0, count.add );
											
											results.forEach( function (obj) {
												obj.age++;
												store.put(obj);
											});
											// Test types of actions..
											t.is( 0, count.add );
											t.is( 0, count.delete );
											t.is( 4, count.change );		// Only listener0 should have been called.

											// Update age again but this time all object will no longer
											// match the query so all will be removed from results.
											// In addition, because this results in a delete operation
											// both listeners should be called.
											
											results.slice().forEach( function (obj) {
												obj.age = 66;
												store.put(obj);
											});

											t.is( 0, results.length );
											t.is( 0, results.total );

											// Test types of actions..
											t.is( 0, count.add );
											t.is( 8, count.delete );	// Number of deletes * 2
											t.is( 4, count.change );

											observer.destroy();
										}
									),
									function (err) {
										defer.errback(err);
									}
								);
								return defer;
							}
						},

					]);

					ready( function () {
						doh.run();

					});


				}
      );
    </script>

  </head>

  <body class="claro">
    <h1 class="DemoTitle">Observer &amp; Observable Extension</h1>
  </body>
</html>